# generate-component-code

## Purpose

To generate production-ready code from component specifications, ensuring that all components are implemented consistently and follow established patterns. This task automates the code generation process while maintaining quality and consistency.

## Process

The Developer will generate clean, maintainable code based on component specifications, using established patterns and best practices to ensure consistency across the entire codebase.

### 1. Code Generation Strategy

#### **Specification Analysis**
- **Component Requirements**: Analyze all component specifications and requirements
- **Design System Integration**: Identify ShadCN components and custom styling needed
- **Responsive Requirements**: Determine responsive behavior and breakpoints
- **Accessibility Requirements**: Identify accessibility features and ARIA attributes

#### **Code Pattern Selection**
- **Component Structure**: Choose appropriate component architecture
- **State Management**: Determine state management approach
- **Props Interface**: Define component props and their types
- **Event Handling**: Plan event handling and callback patterns

### 2. React Component Generation

#### **Component Structure**
- **Functional Components**: Use modern React functional components
- **TypeScript Integration**: Full TypeScript with proper typing
- **Props Interface**: Clear and well-documented props
- **Default Props**: Sensible defaults for all optional props

#### **ShadCN Integration**
- **Component Import**: Proper ShadCN component imports
- **Variant Selection**: Correct component variants and sizes
- **Custom Styling**: Design system styling integration
- **Props Forwarding**: Proper props forwarding to ShadCN components

### 3. Styling Implementation

#### **CSS Integration**
- **Design System Classes**: Use centralized CSS classes
- **Custom Properties**: Leverage CSS custom properties for theming
- **Responsive Design**: Mobile-first responsive implementation
- **Component Variants**: Implement all specified component variants

#### **Styling Patterns**
- **Consistent Naming**: Follow established CSS naming conventions
- **Modular CSS**: Component-specific styling organization
- **Theme Support**: Support for light/dark themes
- **Customization**: Allow for component customization

### 4. Code Quality Standards

#### **TypeScript Implementation**
- **Type Safety**: Full type safety for all props and state
- **Interface Definition**: Clear interfaces for all component APIs
- **Generic Types**: Use generics where appropriate
- **Type Documentation**: Document all types and interfaces

#### **Performance Optimization**
- **Memoization**: Use React.memo for performance optimization
- **Callback Optimization**: Optimize callback functions
- **Bundle Size**: Minimize bundle size impact
- **Lazy Loading**: Implement lazy loading where appropriate

### 5. Accessibility Implementation

#### **ARIA Attributes**
- **Semantic HTML**: Use semantic HTML elements
- **ARIA Labels**: Proper ARIA labeling
- **Role Attributes**: Appropriate role attributes
- **State Management**: ARIA state attributes

#### **Keyboard Navigation**
- **Tab Order**: Logical tab order
- **Keyboard Shortcuts**: Appropriate keyboard shortcuts
- **Focus Management**: Proper focus handling
- **Screen Reader**: Screen reader compatibility

### 6. Responsive Design Implementation

#### **Mobile-First Approach**
- **Base Styles**: Mobile-optimized base styles
- **Breakpoint Progression**: Progressive enhancement for larger screens
- **Touch Targets**: Appropriate touch target sizes
- **Performance**: Optimized for mobile performance

#### **Responsive Patterns**
- **Flexible Layouts**: Use flexible layout patterns
- **Responsive Typography**: Scalable typography
- **Adaptive Components**: Components that adapt to screen size
- **Cross-Device**: Consistent experience across devices

### 7. Code Generation Process

#### **Template-Based Generation**
- **Component Templates**: Use established component templates
- **Pattern Libraries**: Leverage existing code patterns
- **Consistency**: Ensure consistency across all generated code
- **Maintainability**: Generate maintainable and readable code

#### **Quality Assurance**
- **Code Review**: Review generated code for quality
- **Testing**: Test generated components
- **Documentation**: Generate comprehensive documentation
- **Validation**: Validate against specifications

### 8. Integration with Design System

#### **Design Token Usage**
- **Color Tokens**: Use centralized color system
- **Typography Tokens**: Apply consistent typography
- **Spacing Tokens**: Use standardized spacing
- **Component Tokens**: Apply component-specific styling

#### **Component Library Integration**
- **Consistent API**: Consistent component APIs
- **Documentation**: Clear usage documentation
- **Examples**: Code examples and usage patterns
- **Testing**: Component testing and validation

## Output

Production-ready code that includes:

- **React Components**: Clean, maintainable React components
- **TypeScript**: Full TypeScript implementation with proper typing
- **ShadCN Integration**: Properly integrated ShadCN/UI components
- **Design System Styling**: Consistent styling using centralized CSS
- **Accessibility**: Built-in accessibility features
- **Responsive Design**: Mobile-first responsive implementation
- **Documentation**: Clear usage and customization documentation

## Integration with WPS2C Workflow

### **Specification-Driven Development**
- Code generation based on component specifications
- Consistent implementation across all components
- Quality assurance through specification validation
- Iterative refinement based on feedback

### **Team Collaboration**
- Clear code structure for team collaboration
- Consistent patterns for easy maintenance
- Documentation for effective handoff
- Quality standards for reliable implementation

### **Design System Integration**
- Components integrate seamlessly with design system
- Consistent styling and behavior patterns
- Easy maintenance and updates
- Scalable architecture for growth

This task ensures that the WPS2C methodology produces high-quality, production-ready code that follows established patterns and integrates seamlessly with the design system while maintaining the collaborative and systematic approach that makes the methodology effective.
